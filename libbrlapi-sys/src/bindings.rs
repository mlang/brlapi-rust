/* automatically generated by rust-bindgen */

pub const BRLAPI_RELEASE: &'static [u8; 6usize] = b"0.7.0\0";
pub const BRLAPI_MAJOR: u32 = 0;
pub const BRLAPI_MINOR: u32 = 7;
pub const BRLAPI_REVISION: u32 = 0;
pub const BRLAPI_SOCKETPORTNUM: u32 = 4101;
pub const BRLAPI_SOCKETPORT: &'static [u8; 5usize] = b"4101\0";
pub const BRLAPI_SOCKETPATH: &'static [u8; 16usize] = b"/var/lib/BrlAPI\0";
pub const BRLAPI_ETCDIR: &'static [u8; 5usize] = b"/etc\0";
pub const BRLAPI_AUTHKEYFILE: &'static [u8; 11usize] = b"brlapi.key\0";
pub const BRLAPI_DEFAUTH_KEYFILE: &'static [u8; 24usize] = b"keyfile:/etc/brlapi.key\0";
pub const BRLAPI_DEFAUTH_POLKIT: &'static [u8; 1usize] = b"\0";
pub const BRLAPI_DEFAUTH: &'static [u8; 24usize] = b"keyfile:/etc/brlapi.key\0";
pub const BRLAPI_MAXNAMELENGTH: u32 = 31;
pub const BRLAPI_TTY_DEFAULT: i32 = -1;
pub const BRLAPI_DISPLAY_DEFAULT: i32 = -1;
pub const BRLAPI_CURSOR_LEAVE: i32 = -1;
pub const BRLAPI_CURSOR_OFF: u32 = 0;
pub const BRLAPI_PRIxKEYCODE: &'static [u8; 3usize] = b"lx\0";
pub const BRLAPI_PRIuKEYCODE: &'static [u8; 3usize] = b"lu\0";
pub const BRLAPI_KEY_FLAGS_SHIFT: u32 = 32;
pub const BRLAPI_KEY_TYPE_SHIFT: u32 = 29;
pub const BRLAPI_KEY_CODE_SHIFT: u32 = 0;
pub const BRLAPI_KEY_CMD_BLK_SHIFT: u32 = 16;
pub const BRLAPI_KEY_CMD_ARG_SHIFT: u32 = 0;
pub const BRLAPI_DOT1: u32 = 1;
pub const BRLAPI_DOT2: u32 = 2;
pub const BRLAPI_DOT3: u32 = 4;
pub const BRLAPI_DOT4: u32 = 8;
pub const BRLAPI_DOT5: u32 = 16;
pub const BRLAPI_DOT6: u32 = 32;
pub const BRLAPI_DOT7: u32 = 64;
pub const BRLAPI_DOT8: u32 = 128;
pub const BRLAPI_DOTC: u32 = 256;
pub const BRLAPI_DOT_CHORD: u32 = 256;
pub const BRLAPI_UC_ROW: u32 = 10240;
pub const BRLAPI_ERROR_SUCCESS: u32 = 0;
pub const BRLAPI_ERROR_NOMEM: u32 = 1;
pub const BRLAPI_ERROR_TTYBUSY: u32 = 2;
pub const BRLAPI_ERROR_DEVICEBUSY: u32 = 3;
pub const BRLAPI_ERROR_UNKNOWN_INSTRUCTION: u32 = 4;
pub const BRLAPI_ERROR_ILLEGAL_INSTRUCTION: u32 = 5;
pub const BRLAPI_ERROR_INVALID_PARAMETER: u32 = 6;
pub const BRLAPI_ERROR_INVALID_PACKET: u32 = 7;
pub const BRLAPI_ERROR_CONNREFUSED: u32 = 8;
pub const BRLAPI_ERROR_OPNOTSUPP: u32 = 9;
pub const BRLAPI_ERROR_GAIERR: u32 = 10;
pub const BRLAPI_ERROR_LIBCERR: u32 = 11;
pub const BRLAPI_ERROR_UNKNOWNTTY: u32 = 12;
pub const BRLAPI_ERROR_PROTOCOL_VERSION: u32 = 13;
pub const BRLAPI_ERROR_EOF: u32 = 14;
pub const BRLAPI_ERROR_EMPTYKEY: u32 = 15;
pub const BRLAPI_ERROR_DRIVERERROR: u32 = 16;
pub const BRLAPI_ERROR_AUTHENTICATION: u32 = 17;
pub const BRLERR_SUCCESS: u32 = 0;
pub const BRLERR_NOMEM: u32 = 1;
pub const BRLERR_TTYBUSY: u32 = 2;
pub const BRLERR_DEVICEBUSY: u32 = 3;
pub const BRLERR_UNKNOWN_INSTRUCTION: u32 = 4;
pub const BRLERR_ILLEGAL_INSTRUCTION: u32 = 5;
pub const BRLERR_INVALID_PARAMETER: u32 = 6;
pub const BRLERR_INVALID_PACKET: u32 = 7;
pub const BRLERR_CONNREFUSED: u32 = 8;
pub const BRLERR_OPNOTSUPP: u32 = 9;
pub const BRLERR_GAIERR: u32 = 10;
pub const BRLERR_LIBCERR: u32 = 11;
pub const BRLERR_UNKNOWNTTY: u32 = 12;
pub const BRLERR_PROTOCOL_VERSION: u32 = 13;
pub const BRLERR_EOF: u32 = 14;
pub const BRLERR_EMPTYKEY: u32 = 15;
pub const BRLERR_DRIVERERROR: u32 = 16;
extern "C" {
    #[doc = " Returns the version of the library"]
    pub fn brlapi_getLibraryVersion(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        revision: *mut ::std::os::raw::c_int,
    );
}
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __ssize_t = ::std::os::raw::c_long;
pub type ssize_t = __ssize_t;
pub type size_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct brlapi_handle_t {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Returns the size of an object of type brlapi_handle_t in bytes"]
    pub fn brlapi_getHandleSize() -> size_t;
}
pub type brlapi_fileDescriptor = ::std::os::raw::c_int;
#[doc = " \\brief Settings structure for \\e BrlAPI connection"]
#[doc = ""]
#[doc = " This structure holds every parameter needed to connect to \\e BrlAPI: which"]
#[doc = " file the authorization key can be found in and which computer to connect to."]
#[doc = ""]
#[doc = " \\par Examples:"]
#[doc = " \\code"]
#[doc = " brlapi_connectionSettings_t settings;"]
#[doc = ""]
#[doc = " settings.auth=\"/etc/brlapi.key\";"]
#[doc = " settings.host=\"foo\";"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " \\e libbrlapi will read authorization key from file \\p /etc/brlapi.key"]
#[doc = " and connect to the machine called \"foo\", on the default TCP port."]
#[doc = ""]
#[doc = " \\code"]
#[doc = " settings.host=\"10.1.0.2\";"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " lets directly enter an IP address instead of a machine name."]
#[doc = ""]
#[doc = " \\code"]
#[doc = " settings.host=\":1\";"]
#[doc = " \\endcode"]
#[doc = ""]
#[doc = " lets \\e libbrlapi connect to the local computer, on port BRLAPI_SOCKETPORTNUM+1"]
#[doc = ""]
#[doc = " \\sa brlapi_openConnection()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct brlapi_connectionSettings_t {
    #[doc = " For security reasons, \\e libbrlapi has to get authorized to connect to the"]
    #[doc = " \\e BrlAPI server. This can be done via a secret key, for instance. This is"]
    #[doc = " the path to the file which holds it; it will hence have to be readable by"]
    #[doc = " the application."]
    #[doc = ""]
    #[doc = " Setting \\c NULL defaults it to local installation setup or to the content"]
    #[doc = " of the BRLAPI_AUTH environment variable, if it exists."]
    pub auth: *const ::std::os::raw::c_char,
    #[doc = " This tells where the \\e BrlAPI server resides: it might be listening on"]
    #[doc = " another computer, on any TCP port. It should look like \"foo:1\", which"]
    #[doc = " means TCP port number BRLAPI_SOCKETPORTNUM+1 on computer called \"foo\"."]
    #[doc = " \\note Please check that resolving this name works before complaining"]
    #[doc = ""]
    #[doc = " Settings \\c NULL defaults it to localhost, using the local installation's"]
    #[doc = " default TCP port, or to the content of the BRLAPI_HOST environment"]
    #[doc = " variable, if it exists."]
    pub host: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_brlapi_connectionSettings_t() {
    assert_eq!(
        ::std::mem::size_of::<brlapi_connectionSettings_t>(),
        16usize,
        concat!("Size of: ", stringify!(brlapi_connectionSettings_t))
    );
    assert_eq!(
        ::std::mem::align_of::<brlapi_connectionSettings_t>(),
        8usize,
        concat!("Alignment of ", stringify!(brlapi_connectionSettings_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<brlapi_connectionSettings_t>())).auth as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_connectionSettings_t),
            "::",
            stringify!(auth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<brlapi_connectionSettings_t>())).host as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_connectionSettings_t),
            "::",
            stringify!(host)
        )
    );
}
extern "C" {
    pub fn brlapi__openConnection(
        handle: *mut brlapi_handle_t,
        desiredSettings: *const brlapi_connectionSettings_t,
        actualSettings: *mut brlapi_connectionSettings_t,
    ) -> brlapi_fileDescriptor;
}
extern "C" {
    pub fn brlapi__closeConnection(handle: *mut brlapi_handle_t);
}
extern "C" {
    pub fn brlapi__setClientData(handle: *mut brlapi_handle_t, data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn brlapi__getClientData(handle: *mut brlapi_handle_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn brlapi__getDriverName(
        handle: *mut brlapi_handle_t,
        buffer: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__getModelIdentifier(
        handle: *mut brlapi_handle_t,
        buffer: *mut ::std::os::raw::c_char,
        size: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__getDisplaySize(
        handle: *mut brlapi_handle_t,
        x: *mut ::std::os::raw::c_uint,
        y: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__enterTtyMode(
        handle: *mut brlapi_handle_t,
        tty: ::std::os::raw::c_int,
        driver: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__enterTtyModeWithPath(
        handle: *mut brlapi_handle_t,
        ttys: *mut ::std::os::raw::c_int,
        count: ::std::os::raw::c_int,
        driver: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__leaveTtyMode(handle: *mut brlapi_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__setFocus(
        handle: *mut brlapi_handle_t,
        tty: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__writeText(
        handle: *mut brlapi_handle_t,
        cursor: ::std::os::raw::c_int,
        text: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__writeWText(
        handle: *mut brlapi_handle_t,
        cursor: ::std::os::raw::c_int,
        text: *const wchar_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__writeDots(
        handle: *mut brlapi_handle_t,
        dots: *const ::std::os::raw::c_uchar,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Structure containing arguments to be given to brlapi_write()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct brlapi_writeArguments_t {
    pub displayNumber: ::std::os::raw::c_int,
    pub regionBegin: ::std::os::raw::c_uint,
    pub regionSize: ::std::os::raw::c_uint,
    pub text: *mut ::std::os::raw::c_char,
    pub textSize: ::std::os::raw::c_int,
    pub andMask: *mut ::std::os::raw::c_uchar,
    pub orMask: *mut ::std::os::raw::c_uchar,
    pub cursor: ::std::os::raw::c_int,
    pub charset: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_brlapi_writeArguments_t() {
    assert_eq!(
        ::std::mem::size_of::<brlapi_writeArguments_t>(),
        64usize,
        concat!("Size of: ", stringify!(brlapi_writeArguments_t))
    );
    assert_eq!(
        ::std::mem::align_of::<brlapi_writeArguments_t>(),
        8usize,
        concat!("Alignment of ", stringify!(brlapi_writeArguments_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<brlapi_writeArguments_t>())).displayNumber as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_writeArguments_t),
            "::",
            stringify!(displayNumber)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<brlapi_writeArguments_t>())).regionBegin as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_writeArguments_t),
            "::",
            stringify!(regionBegin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<brlapi_writeArguments_t>())).regionSize as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_writeArguments_t),
            "::",
            stringify!(regionSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_writeArguments_t>())).text as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_writeArguments_t),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<brlapi_writeArguments_t>())).textSize as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_writeArguments_t),
            "::",
            stringify!(textSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_writeArguments_t>())).andMask as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_writeArguments_t),
            "::",
            stringify!(andMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_writeArguments_t>())).orMask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_writeArguments_t),
            "::",
            stringify!(orMask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_writeArguments_t>())).cursor as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_writeArguments_t),
            "::",
            stringify!(cursor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_writeArguments_t>())).charset as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_writeArguments_t),
            "::",
            stringify!(charset)
        )
    );
}
extern "C" {
    pub fn brlapi__write(
        handle: *mut brlapi_handle_t,
        arguments: *const brlapi_writeArguments_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " \\defgroup brlapi_keycodes Types and Defines for \\e BrlAPI Key Codes"]
#[doc = ""]
#[doc = " Key codes are unsigned 64 bit integers.  This 64-bit space is split into 3"]
#[doc = " parts:"]
#[doc = ""]
#[doc = " - bits 63-32 (BRLAPI_KEY_FLAGS_MASK), flags: bits 39-32 are standard X"]
#[doc = " modifiers (shift, control, meta, ...). Other flags are used for some commands,"]
#[doc = " see documentation of BRLAPI_KEY_FLG_* for their respective uses."]
#[doc = " - bits 31-29 (BRLAPI_KEY_TYPE_MASK), key type: either BRLAPI_KEY_TYPE_CMD for"]
#[doc = " braille commands, or BRLAPI_KEY_TYPE_SYM for standard X keysyms."]
#[doc = " - bits 28-0 (BRLAPI_KEY_CODE_MASK), key code: for braille commands, see"]
#[doc = " BRLAPI_KEY_CMD_* ; for standard X keysyms, this is the keysym value, see"]
#[doc = " X11 documentation, a complete list is probably available on your system in"]
#[doc = " /usr/include/X11/keysymdef.h"]
#[doc = ""]
#[doc = " The third part is itself split into two parts: a command number and a command"]
#[doc = " value.  The relative sizes of these parts vary according to the key type."]
#[doc = ""]
#[doc = " For a braille command, bits 28-16 (BRLAPI_KEY_CMD_BLK_MASK) hold the braille"]
#[doc = " command number, while bits 15-0 (BRLAPI_KEY_CMD_ARG_MASK) hold the command"]
#[doc = " value."]
#[doc = ""]
#[doc = " For a X keysym, if it is a unicode keysym (0x1uvwxyz), then the command"]
#[doc = " number part is 0x1000000 and the value part is 0xuvwxyz. Else, the command"]
#[doc = " part is held by bits 28-8 and the value part is held by bits 7-0. This"]
#[doc = " permits to easily handle usual cases like 0x00xy (latin1), 0x01xy (latin2),"]
#[doc = " XK_Backspace (0xff08, backspace), XK_Tab (0xff09, tab), ..."]
#[doc = ""]
#[doc = " For instance, if key == 0x0000000020010008,"]
#[doc = " - (key & BRLAPI_KEY_TYPE_MASK) == BRLAPI_KEY_TYPE_CMD, so it's a braille"]
#[doc = " command"]
#[doc = " - (key & BRLAPI_KEY_CMD_BLK_MASK) == BRLAPI_KEY_CMD_ROUTE, so it's the"]
#[doc = " braille route command."]
#[doc = " - (key & BRLAPI_KEY_CMD_ARG_MASK) == 8, so the highlighted cell is the 9th"]
#[doc = " one (cells are numbered from 0)"]
#[doc = " - (key & BRLAPI_KEY_FLAGS_MASK) == 0, so no modifier key was pressed during"]
#[doc = " the command, and no particular flag applies to the command."]
#[doc = ""]
#[doc = " if key == 0x000000010000FF09,"]
#[doc = " - (key & BRLAPI_KEY_TYPE_MASK) == BRLAPI_KEY_TYPE_SYM, so it's a keysym"]
#[doc = " - (key & BRLAPI_KEY_CODE_MASK) == XK_Tab, so it's the tab key."]
#[doc = " BRLAPI_KEY_SYM_TAB can also be used here, as well as a few other"]
#[doc = " BRLAPI_KEY_SYM_* constants which are provided to avoid having to include"]
#[doc = " X11/keysymdef.h"]
#[doc = " - (key & BRLAPI_KEY_FLAGS_MASK) == BRLAPI_KEY_FLG_SHIFT, so the shift"]
#[doc = " modifier was pressed during the command."]
#[doc = ""]
#[doc = " in the X11 standard some keysyms are directly unicode, for instance if"]
#[doc = " key == 0x0000000001001EA0,"]
#[doc = " - (key & BRLAPI_KEY_TYPE_MASK) == BRLAPI_KEY_TYPE_SYM, so it's a keysym"]
#[doc = " - (key & BRLAPI_KEY_SYM_UNICODE) != 0 so it's a unicode keysym, whose value"]
#[doc = " is key & (BRLAPI_KEY_SYM_UNICODE-1).  Of course, one can also consider"]
#[doc = " (key & BRLAPI_KEY_CODE_MASK) == XK_Abelowdot"]
#[doc = " - (key & BRLAPI_KEY_FLAGS_MASK) == 0, so no modifier key was pressed during"]
#[doc = " the command, and no particular flag applies to the command."]
#[doc = ""]
#[doc = " The brlapi_expandKeyCode() function may be used for splitting key codes into"]
#[doc = " these parts."]
#[doc = " @{"]
pub type brlapi_keyCode_t = u64;
#[doc = " Structure holding the components of a key code as returned by brlapi_expandKeyCode()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct brlapi_expandedKeyCode_t {
    pub type_: ::std::os::raw::c_uint,
    pub command: ::std::os::raw::c_uint,
    pub argument: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_brlapi_expandedKeyCode_t() {
    assert_eq!(
        ::std::mem::size_of::<brlapi_expandedKeyCode_t>(),
        16usize,
        concat!("Size of: ", stringify!(brlapi_expandedKeyCode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<brlapi_expandedKeyCode_t>(),
        4usize,
        concat!("Alignment of ", stringify!(brlapi_expandedKeyCode_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_expandedKeyCode_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_expandedKeyCode_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<brlapi_expandedKeyCode_t>())).command as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_expandedKeyCode_t),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<brlapi_expandedKeyCode_t>())).argument as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_expandedKeyCode_t),
            "::",
            stringify!(argument)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_expandedKeyCode_t>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_expandedKeyCode_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[doc = " Expand the components of a key code"]
    #[doc = ""]
    #[doc = " \\param code the key code to be expanded"]
    #[doc = " \\param expansion pointer to the structure that receives the components"]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error"]
    pub fn brlapi_expandKeyCode(
        code: brlapi_keyCode_t,
        expansion: *mut brlapi_expandedKeyCode_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " Structure holding the components of a key code as returned by brlapi_describeKeyCode()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct brlapi_describedKeyCode_t {
    pub type_: *const ::std::os::raw::c_char,
    pub command: *const ::std::os::raw::c_char,
    pub argument: ::std::os::raw::c_uint,
    pub flags: ::std::os::raw::c_uint,
    pub flag: [*const ::std::os::raw::c_char; 32usize],
    pub values: brlapi_expandedKeyCode_t,
}
#[test]
fn bindgen_test_layout_brlapi_describedKeyCode_t() {
    assert_eq!(
        ::std::mem::size_of::<brlapi_describedKeyCode_t>(),
        296usize,
        concat!("Size of: ", stringify!(brlapi_describedKeyCode_t))
    );
    assert_eq!(
        ::std::mem::align_of::<brlapi_describedKeyCode_t>(),
        8usize,
        concat!("Alignment of ", stringify!(brlapi_describedKeyCode_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_describedKeyCode_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_describedKeyCode_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<brlapi_describedKeyCode_t>())).command as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_describedKeyCode_t),
            "::",
            stringify!(command)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<brlapi_describedKeyCode_t>())).argument as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_describedKeyCode_t),
            "::",
            stringify!(argument)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_describedKeyCode_t>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_describedKeyCode_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_describedKeyCode_t>())).flag as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_describedKeyCode_t),
            "::",
            stringify!(flag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<brlapi_describedKeyCode_t>())).values as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_describedKeyCode_t),
            "::",
            stringify!(values)
        )
    );
}
extern "C" {
    #[doc = " Describe the components of a key code."]
    #[doc = ""]
    #[doc = " \\param code the keycode to be described"]
    #[doc = " \\param description pointer to the structure that receives the description"]
    #[doc = ""]
    #[doc = " \\return 0 on success, -1 on error"]
    pub fn brlapi_describeKeyCode(
        code: brlapi_keyCode_t,
        description: *mut brlapi_describedKeyCode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__readKey(
        handle: *mut brlapi_handle_t,
        wait: ::std::os::raw::c_int,
        code: *mut brlapi_keyCode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__readKeyWithTimeout(
        handle: *mut brlapi_handle_t,
        timeout_ms: ::std::os::raw::c_int,
        code: *mut brlapi_keyCode_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< all keys, code must be 0"]
pub const brlapi_rangeType_t_brlapi_rangeType_all: brlapi_rangeType_t = 0;
#[doc = "< all keys of a given type"]
pub const brlapi_rangeType_t_brlapi_rangeType_type: brlapi_rangeType_t = 1;
#[doc = "< all keys of a given command block, i.e. matching the key type and command parts"]
pub const brlapi_rangeType_t_brlapi_rangeType_command: brlapi_rangeType_t = 2;
#[doc = "< a given key with any flags"]
pub const brlapi_rangeType_t_brlapi_rangeType_key: brlapi_rangeType_t = 3;
#[doc = "< a given key code"]
pub const brlapi_rangeType_t_brlapi_rangeType_code: brlapi_rangeType_t = 4;
#[doc = " types of key ranges"]
pub type brlapi_rangeType_t = u32;
extern "C" {
    pub fn brlapi__ignoreKeys(
        handle: *mut brlapi_handle_t,
        type_: brlapi_rangeType_t,
        keys: *const brlapi_keyCode_t,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__acceptKeys(
        handle: *mut brlapi_handle_t,
        type_: brlapi_rangeType_t,
        keys: *const brlapi_keyCode_t,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__ignoreAllKeys(handle: *mut brlapi_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__acceptAllKeys(handle: *mut brlapi_handle_t) -> ::std::os::raw::c_int;
}
#[doc = " Type for raw keycode ranges"]
#[doc = ""]
#[doc = " Denotes the set of keycodes between \\e first and \\e last (inclusive)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct brlapi_range_t {
    #[doc = "< first key of the range"]
    pub first: brlapi_keyCode_t,
    #[doc = "< last key of the range"]
    pub last: brlapi_keyCode_t,
}
#[test]
fn bindgen_test_layout_brlapi_range_t() {
    assert_eq!(
        ::std::mem::size_of::<brlapi_range_t>(),
        16usize,
        concat!("Size of: ", stringify!(brlapi_range_t))
    );
    assert_eq!(
        ::std::mem::align_of::<brlapi_range_t>(),
        8usize,
        concat!("Alignment of ", stringify!(brlapi_range_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_range_t>())).first as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_range_t),
            "::",
            stringify!(first)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_range_t>())).last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_range_t),
            "::",
            stringify!(last)
        )
    );
}
extern "C" {
    pub fn brlapi__ignoreKeyRanges(
        handle: *mut brlapi_handle_t,
        ranges: *const brlapi_range_t,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__acceptKeyRanges(
        handle: *mut brlapi_handle_t,
        ranges: *const brlapi_range_t,
        count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__enterRawMode(
        handle: *mut brlapi_handle_t,
        driver: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__leaveRawMode(handle: *mut brlapi_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__sendRaw(
        handle: *mut brlapi_handle_t,
        buffer: *const ::std::os::raw::c_void,
        size: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn brlapi__recvRaw(
        handle: *mut brlapi_handle_t,
        buffer: *mut ::std::os::raw::c_void,
        size: size_t,
    ) -> ssize_t;
}
extern "C" {
    pub fn brlapi__suspendDriver(
        handle: *mut brlapi_handle_t,
        driver: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__resumeDriver(handle: *mut brlapi_handle_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Print a BrlAPI error message"]
    #[doc = ""]
    #[doc = " brlapi_perror() reads ::brlapi_error, and acts just like perror()."]
    pub fn brlapi_perror(s: *const ::std::os::raw::c_char);
}
#[doc = " All information that is needed to describe brlapi errors"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct brlapi_error_t {
    pub brlerrno: ::std::os::raw::c_int,
    pub libcerrno: ::std::os::raw::c_int,
    pub gaierrno: ::std::os::raw::c_int,
    pub errfun: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_brlapi_error_t() {
    assert_eq!(
        ::std::mem::size_of::<brlapi_error_t>(),
        24usize,
        concat!("Size of: ", stringify!(brlapi_error_t))
    );
    assert_eq!(
        ::std::mem::align_of::<brlapi_error_t>(),
        8usize,
        concat!("Alignment of ", stringify!(brlapi_error_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_error_t>())).brlerrno as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_error_t),
            "::",
            stringify!(brlerrno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_error_t>())).libcerrno as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_error_t),
            "::",
            stringify!(libcerrno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_error_t>())).gaierrno as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_error_t),
            "::",
            stringify!(gaierrno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<brlapi_error_t>())).errfun as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(brlapi_error_t),
            "::",
            stringify!(errfun)
        )
    );
}
extern "C" {
    #[doc = " Get per-thread error location"]
    #[doc = ""]
    #[doc = " In multithreaded software, ::brlapi_error is thread-specific, so api.h"]
    #[doc = " cheats about the brlapi_error token and actually calls"]
    #[doc = " brlapi_error_location()."]
    #[doc = ""]
    #[doc = " This gets the thread specific location of global variable ::brlapi_error"]
    pub fn brlapi_error_location() -> *mut brlapi_error_t;
}
extern "C" {
    #[doc = " Get plain error message"]
    #[doc = ""]
    #[doc = " brlapi_strerror() returns the plain error message corresponding to its"]
    #[doc = " argument."]
    pub fn brlapi_strerror(error: *const brlapi_error_t) -> *const ::std::os::raw::c_char;
}
#[doc = " Type for packet type. Only unsigned can cross networks, 32bits"]
pub type brlapi_packetType_t = u32;
extern "C" {
    #[doc = " Get plain packet type"]
    #[doc = ""]
    #[doc = " brlapi_getPacketTypeName() returns the plain packet type name corresponding to"]
    #[doc = " its argument."]
    pub fn brlapi_getPacketTypeName(type_: brlapi_packetType_t) -> *const ::std::os::raw::c_char;
}
pub type brlapi__exceptionHandler_t = ::std::option::Option<
    unsafe extern "C" fn(
        handle: *mut brlapi_handle_t,
        error: ::std::os::raw::c_int,
        type_: brlapi_packetType_t,
        packet: *const ::std::os::raw::c_void,
        size: size_t,
    ),
>;
extern "C" {
    pub fn brlapi__strexception(
        handle: *mut brlapi_handle_t,
        buffer: *mut ::std::os::raw::c_char,
        bufferSize: size_t,
        error: ::std::os::raw::c_int,
        type_: brlapi_packetType_t,
        packet: *const ::std::os::raw::c_void,
        packetSize: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brlapi__setExceptionHandler(
        handle: *mut brlapi_handle_t,
        handler: brlapi__exceptionHandler_t,
    ) -> brlapi__exceptionHandler_t;
}
extern "C" {
    pub fn brlapi__defaultExceptionHandler(
        handle: *mut brlapi_handle_t,
        error: ::std::os::raw::c_int,
        type_: brlapi_packetType_t,
        packet: *const ::std::os::raw::c_void,
        size: size_t,
    );
}
